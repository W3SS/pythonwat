Não é bem assim... quando Python não é como você espera

Descrição:
Apesar de ser uma linguagem bonita e fácil de aprender, nem tudo em Python é como esperamos. Vamos explorar aspectos da linguagem que não são triviais e oferecer alternativas. Esta palestra é essencial para iniciantes, mas pode prover insights para pythonistas experientes também.

Alguns dos tópicos que vamos explorar:
- Esquecendo __init__.py
- Esquecendo parênteses
- Escopo
- Referências
- Operador is
- Variáveis de classe
- Argumentos default mutáveis
- Closures com late binding
- Sobrescrevendo a biblioteca padrão sem querer
- Capturando múltiplas exceções
- .pyc WILL NOT DO

-----------------------------------------------------------------------------------------------------

# __init__.py
http://stackoverflow.com/questions/448271/what-is-init-py-for
http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html
https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages
http://chimera.labs.oreilly.com/books/1230000000393/ch10.html#_discussion_169
http://chimera.labs.oreilly.com/books/1230000000393/ch10.html#namespacepackage
https://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/

flat is better than nested 
prevent name clashes of directories with common package names 
allows you to define any variable at the package level
__all__ can define subpackages to be imported when you do `import *
keep __init__.py thin, because explicit is better than implicit
declare a public API on __init__.py (see: https://github.com/kennethreitz/requests/blob/master/requests/__init__.py), this is more backwards compatible also, as it uncouples API with internal package implementation
__pycache__

Python versions 3.3 and later support Python packages without an __init__.py file. These packages are known as “namespace packages” and may be spread across multiple directories at different locations on sys.path.

For large frameworks, this can be useful, since it allows parts of a framework to be broken up into separately installed downloads. It also enables people to easily make third-party add-ons and other extensions to such frameworks.

Example of namespace package: zope of Zope 3, OpenMDAO
https://pythonhosted.org/setuptools/setuptools.html
http://openmdao.org/releases/0.0.5/docs/dev-guide/intro.html

Problems: https://specs.openstack.org/openstack/oslo-specs/specs/kilo/drop-namespace-packages.html

The name shadowing trap
$ python -c 'from socket import socket; print("OK!")'
OK!
$ echo 'from socket import socket; print("OK!")' > socket.py
$ python socket.py
Traceback (most recent call last):
  File "socket.py", line 1, in <module>
    from socket import socket
  File "/home/ncoghlan/devel/socket.py", line 1, in <module>
    from socket import socket
ImportError: cannot import name socket

The submodules are added to the package namespace trap
$ python3
>>> import logging
>>> logging.config
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'config'

$ echo "import logging.config" > weirdimport.py
$ python3
>>> import weirdimport
>>> import logging
>>> logging.config
<module 'logging.config' from '/usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/logging/config.py'>

The stale bytecode file trap
http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html#the-stale-bytecode-file-trap

reload modules
http://chimera.labs.oreilly.com/books/1230000000393/ch10.html#_reloading_modules

# Identity DONE
http://stackoverflow.com/a/15172182/145349

>>> a = 256
>>> b = 256
>>> a is b
True

>>> a = 257
>>> b = 257
>>> a is b
False

$ echo 'a = 257
> b = 257
> print a is b' > int_const.py
$ python int_const.py
True

use function `id`

>>> me = {'name': 'Flávio', 'age': 26}
>>> people = [me] * 3
>>> people
[{'name': 'Flávio', 'age': 26}, {'name': 'Flávio', 'age': 26}, {'name': 'Flávio', 'age': 26}]
>>> people[0]['name'] = 'Fulano'
>>> people
[{'name': 'Fulano', 'age': 26}, {'name': 'Fulano', 'age': 26}, {'name': 'Fulano', 'age': 26}]

>>> linha = [' '] * 3
>>> linha
[' ', ' ', ' ']
>>> tabela = [linha] * 3
>>> tabela
[[' ', ' ', ' '], [' ', ' ', ' '], [' ', ' ', ' ']]
>>> def imprimir_tabela():
...     for l in tabela:
...         print(l)
... 
>>> imprimir_tabela()
[' ', ' ', ' ']
[' ', ' ', ' ']
[' ', ' ', ' ']
>>> tabela[0][0] = 'X'
>>> imprimir_tabela()
['X', ' ', ' ']
['X', ' ', ' ']
['X', ' ', ' ']

>>> tabela[0] is tabela[1] and tabela[1] is tabela[2]
True

>>> id(tabela[0]) == id(tabela[1]) == id(tabela[2])
True

>>> tabela[2][0] = 'O'
>>> imprimir_tabela()
['O', ' ', ' ']
['O', ' ', ' ']
['O', ' ', ' ']

>>> tabela = [[' ' for ___ in range(3)] for __ in range(3)]
>>> imprimir_tabela()
[' ', ' ', ' ']
[' ', ' ', ' ']
[' ', ' ', ' ']
>>> tabela[2][0] = 'O'
>>> imprimir_tabela()
[' ', ' ', ' ']
[' ', ' ', ' ']
['O', ' ', ' ']

>>> tabela = [[{}] * 3 for __ in range(3)]
>>> imprimir_tabela()
[{}, {}, {}]
[{}, {}, {}]
[{}, {}, {}]
>>> tabela[0][0]['name'] = 'Fulano'
>>> imprimir_tabela()
[{'name': 'Fulano'}, {'name': 'Fulano'}, {'name': 'Fulano'}]
[{}, {}, {}]
[{}, {}, {}]

# Default args DONE
>>> def adicionar_poddle(caes=[]):
...     caes.append("poddle")
...     return caes
... 
>>> print(adicionar_poddle(['bulldog']))
['bulldog', 'poddle']
>>> print(adicionar_poddle(['beagle']))
['beagle', 'poddle']
>>> print(adicionar_poddle())
['poddle']
>>> print(adicionar_poddle())
['poddle', 'poddle']
>>> print(adicionar_poddle([]))
['poddle']
>>> print(adicionar_poddle([]))
['poddle']
>>> print(adicionar_poddle())
['poddle', 'poddle', 'poddle']

>>> adicionar_poddle.__defaults__
(['poddle', 'poddle', 'poddle'],)
>>> adicionar_poddle.__defaults__[0].append('wtf')
>>> print(adicionar_poddle())
['poddle', 'poddle', 'poddle', 'wtf', 'poddle']

the default value for a function argument is only evaluated once, at the time that the function is defined

>>> def adicionar_poddle(caes=None):
...     if caes is None:
...         caes = []
...     caes.append("poddle")
...     return caes
... 

# Class variables DONE
https://github.com/allisson/django-pagseguro2/pull/6
https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make
https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables

class Dog:
    tricks = []

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

    def print_tricks(self):
        for trick in self.tricks:
            print(trick)

In [54]: teddy = Cachorro()

In [55]: teddy.add_trick('roll over')

In [56]: c1.print_tricks()
roll over

In [57]: tico = Cachorro()

In [58]: tico.print_tricks()
roll over

class Dog:
    def __init__(self):
        self.tricks = []

    # ...

Consider the following example:

>>> class A(object):
...     x = 1
...
>>> class B(A):
...     pass
...
>>> class C(A):
...     pass
...
>>> print A.x, B.x, C.x
1 1 1
Makes sense.

>>> B.x = 2
>>> print A.x, B.x, C.x
1 2 1
Yup, again as expected.

>>> A.x = 3
>>> print A.x, B.x, C.x
3 2 3
What the $%#!&?? We only changed A.x. Why did C.x change too?

When you try to access an attribute from an instance of a class, it first looks at its instance namespace. If it finds the attribute, it returns the associated value. If not, it then looks in the class namespace and returns the attribute (if it’s present, throwing an error otherwise)

# Scope DONE

>>> x = 10
>>> def foo():
...     x += 1
...     print x
...
>>> foo()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in foo
UnboundLocalError: local variable 'x' referenced before assignment

when you make an assignment to a variable in a scope, that variable is automatically considered by Python to be local to that scope and shadows any similarly named variable in any outer scope.

LEGB rule, which is shorthand for Local, Enclosing, Global, Built-in
http://stackoverflow.com/a/292502/145349

>>> lst = [1, 2, 3]
>>> def foo1():
...     lst.append(5)   # This works ok...
...
>>> foo1()
>>> lst
[1, 2, 3, 5]

>>> lst = [1, 2, 3]
>>> def foo2():
...     lst += [5]      # ... but this bombs!
...
>>> foo2()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in foo
UnboundLocalError: local variable 'lst' referenced before assignment

In [59]: a = 1

In [60]: def foo():
   ....:     return a
   ....: 

In [61]: import dis; dis.dis(foo)
  2           0 LOAD_GLOBAL              0 (a)
              3 RETURN_VALUE        

In [62]: def foo():
   ....:     a += 1
   ....:     return a
   ....: 

In [63]: import dis; dis.dis(foo)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_CONST               1 (1)
              6 INPLACE_ADD         
              7 STORE_FAST               0 (a)

  3          10 LOAD_FAST                0 (a)
             13 RETURN_VALUE  

https://docs.python.org/2/library/dis.html#opcode-LOAD_FAST

a += 1 -> a = a + 1

global: https://docs.python.org/3/reference/simple_stmts.html#global
nonlocal: http://stackoverflow.com/a/1261961/145349

# Change list inplace TODO
In [64]: x = [1,2,3] 

In [65]: x
Out[65]: [1, 2, 3]

In [66]: y = x

In [67]: y[:] = [4,5,6]

In [68]: x
Out[68]: [4, 5, 6]

# Late Binding Closures DONE
http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures
>>> def create_multipliers():
...     return [lambda x : i * x for i in range(5)]
>>> for multiplier in create_multipliers():
...     print multiplier(2)
...

You might expect the following output:
0
2
4
6
8

But you actually get:
8
8
8
8
8

values of variables used in closures are looked up at the time the inner function is called

The solution to this common Python problem is a bit of a hack:

>>> def create_multipliers():
...     return [lambda x, i=i : i * x for i in range(5)]
...
>>> for multiplier in create_multipliers():
...     print multiplier(2)
...
0
2
4
6
8

*What’s particularly nasty about this gotcha is the seemingly prevalent misinformation that this has something to do with lambdas in Python. Functions created with a lambda expression are in no way special, and in fact the same exact behavior is exhibited by just using an ordinary def*

# Forgetting parens DONE
https://pythonconquerstheuniverse.wordpress.com/2008/06/04/gotcha-%E2%80%94-forgetting-parentheses/

# Backslashes are escape chars TODO
https://pythonconquerstheuniverse.wordpress.com/2008/06/04/gotcha-%E2%80%94-backslashes-are-escape-characters/

# Tuple assignment DONE
http://stackoverflow.com/a/4285882/145349
In [73]: a = ([42],)

In [74]: a[0] += [43, 44]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-74-ddf9d9661536> in <module>()
----> 1 a[0] += [43, 44]

TypeError: 'tuple' object does not support item assignment

In [75]: a = ([42],)

In [76]: b = a[0]

In [77]: b += [43, 44]

In [78]: b
Out[78]: [42, 43, 44]

# Multiple exceptions DONE
In [80]: try:
    1/0
except IndexError, ZeroDivisionError:
    print('error')
   ....:     
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
<ipython-input-80-fe98d7ca541c> in <module>()
      1 try:
----> 2     1/0
      3 except IndexError, ZeroDivisionError:
      4     print('error')
      5 

ZeroDivisionError: integer division or modulo by zero

In [81]: try:
    1/0
except ZeroDivisionError, IndexError:
    print('error')
   ....:     
error

In [82]: try:
    1/0
except (IndexError, ZeroDivisionError):
    print('error')
   ....:     
error

# Integer base TODO
i = 010        # gives i the value of 8
j = int('010') # gives j the value of 10

correct:

j = int('010', 8)

# Overwritting standard library DONE
>>> list = [1,2,3]
>>> list("abcde")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'list' object is not callable


https://speakerdeck.com/pycon2015/amy-hanlon-investigating-python-wats
http://docs.python-guide.org/en/latest/writing/gotchas/
https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make
https://pythonconquerstheuniverse.wordpress.com/category/python-gotchas/
http://stackoverflow.com/questions/530530/python-2-x-gotchas-and-landmines
https://www.destroyallsoftware.com/talks/wat
